<abstract><heading>Summary</heading>This report details the design and implementation of an anemometer on an FPGA, using Xilinx ISE software. The task was split up into 6 main components, though the design was focused around including the ability to test, through scan. Most design was carried out in schematic form, with one part written in VHDL code. The report includes schematic diagrams for every part of the solution, along with simulation results, and documents any problems encountered, along with their solutions. Also, the necessary scan test patterns have been worked out and included. </abstract><list></list><heading>2. Introduction</heading><heading>2.1. The Project</heading>The main objective of this project was to produce a logic circuit to complement a mechanical anemometer head. The logic must perform the following: <list>Receive a frequency of pulses between 0 and 99Hz from the anemometer head.Calculate the average frequency over 10 second periodsOutput this value to the 7 segment displayUpdate the 7 segment display at the end of each 10 second period</list>The solution was implemented using: <list>Xilinx XC2S300E FPGA (from the Spartan 2E series)Digilent, Inc D2-FT System BoardDigilent, Inc DIO4 Peripheral BoardA Range of Xilinx ISE CAD software toolsModelSim from Model Technology™</list><heading>2.2. Background Information</heading><heading>2.2.1. FPGA Design</heading>Implementing a design using an FPGA is a combined hardware and software solution. This has a big advantage over a purely hardware solution. An FPGA can be programmed and reprogrammed freely without removing it from its application, making it ideal for developing a new design. Partial and incomplete designs can be tested by programming them onto the FPGA, unlike in hardware design, where designs can only be simulated. There can often be significant differences between computer simulation results, and the performance of a design once manufactured. FPGAs are typically programmed using HDLs, although in this project nearly all the design was done by creating logic circuit schematics. The Xilinx software can then 'synthesise' the designs into VHDL. The DIO4 provides, amongst other features: <list>4-digit seven segment LED display;8 individual LEDs;4 pushbuttons;8 slide switches; [1]</list>The D2-FT provides, amongst other features: <list>An SMD 50MHz oscillator, and a socket for a second oscillator;A JTAG programming port; [2]</list><heading>2.2.2. Design for Test</heading>Testing a logic circuit once it has been implemented is not as simple as it once was. Modern ICs frequently contain millions of logic gates which means that exhaustive testing of a chip is impossible. However, manufacturers still need to guarantee the functionality of their products. There are methods of testing circuitry that enable manufacturers to do this, but they require some extra logic to be included in the design. Therefore, the complexity of present circuits and the advent of SOCs makes it mandatory to start considering testing early in the design process [3]. One such method of testing is Scan. The basic idea is to connect all of the flip-flops in a circuit into a serial chain (shift register) giving the ability to scan data in or out. Multiplexers are included, to select whether the circuit is configured for normal operation, or as a scan chain. The circuit in figure 2.2.1 would be tested as follows: Pass values into 'scan in', and using the scan chain, set the initial values of flip-flops. In normal operation mode, pass the values through the combinational logic. Use the scan chain to clock the outputs through to 'scan out', where they can be checked against theoretical outputs. This process requires pre-determined test patterns to be used as the initial flip-flop values. These patterns are specially calculated to highlight any possible faults. <figure/>The circuits in this project also include a 'scanClock' and 'clockSelect' pin, which means the clocking through of values can be done at a controlled speed, or with a push button, since no dedicated test hardware is available. This technique is also necessary to convert asynchronous circuits, such as the divider in 3.3, into a synchronous form that can be used as a shift register. <heading>3. Procedure</heading><heading>3.1. Overall Task</heading>The main design problem has been tackled by splitting it into a number of relatively simple parts: <figure/>The anemometer head had been previously constructed from aluminium. Its design and construction is not documented in this report. <heading>3.2. BCD Counter</heading>The BCD counter forms the basis for the entire circuit. Its job is to count the input pulses from the anemometer head over 10 second periods. After 10 seconds, it receives a reset signal from the timing generator. It was designed first, as several other components in this project can be easily adapted from the schematic of a BCD counter. In terms of the logic, it is the most complex component to design. The counter needs to be modulo-10, which is not a power of two, so a synchronous setup was used, with D-type flip-flops to simplify design. 4 flip-flops (A, B, C, D) were required, since log 210 = 3.3. The flip-flops needed to go through the following states: <table/>In order to achieve these states in a synchronous counter, the flip flops must be set up with the following logic before their D input (the full derivation using K-maps is given in Appendix A):  FORMULA   FORMULA   FORMULA   FORMULA  The fact that D-flip-flops were used means no control over the initial state of the flip-flops is given. Therefore, it is important to check the unwanted states:  FORMULA   FORMULA   FORMULA   FORMULA   FORMULA  Several of the unwanted states are followed by another unwanted state. However, they all lead to acceptable states within 3 (max) state changes, so no revision of the logic is necessary. The logic expressions were constructed with gates in a schematic diagram using Xilinx ECS. The diagram is show in figure B.1 of Appendix B. While this counter did count through 10 states in natural binary, there were several modifications required before the BCD counter would exactly suit this project. Firstly, the simple flip-flops were replaced by ones with a 'clear' input. This allows the counter to be reset at the end of each 10 second period. Secondly, since an essential part of this project is the ability to test the logic after implementation, the schematic was revised, to include: <list>scanEnable (input pin)scanIn (input pin)scanOut (output pin)clockSelect (input pin)scanClock (input pin)</list>An explanation of Scan is given in section 2.2.2. Also a multiplexer was included on the 'clear' input. Otherwise, the scan chain could be interrupted if the clear input became HIGH. Note: there is no included ability to test the multiplexers involved in the scan process. These are assumed to be fault free. The final schematic for the BCD counter is figure B.2 of Appendix B. Using Xilinx Project Navigator, the schematic was then synthesised, to create a VHDL (.vhf/.vhd) file, which was simulated in ModelSim. For simulation results, see section 4.2. <heading>3.3. Clock</heading>The purpose of the clock is to supply a regular 0.8Hz square wave to the timing generator, so that the appropriate timing signal can be created. The oscillator provided on the D2-FT runs at 50Mhz. A 0.8Hz clock (as required) can be produced by scaling down this fast clock with a prescaler. The simplest type of prescaler would be asynchronous, with successive 'divide by 2' stages. The number of stages required is given by:  FORMULA  Therefore 26 flip-flops were used in this prescaler. The schematic for this prescaler has been named "div26", to avoid confusion with the prescaler which scales the input from the anemometer head. Rounding up to 26 flip-flops resulted in an imprecise frequency for the clock. However, a clock running at  FORMULA  Hz is accurate enough for the specification of this project. Drawing out a schematic with 26 flip-flops would be time consuming (and thus error prone), and difficult to fit on a sheet. Also, a design which divides by 67k is very difficult to simulate, since it would take 67 thousand clock cycles to see one cycle of the output. This simulation would take hours. Instead, the 26 stages were broken down into 5 occurrences of a block with 5 stages, and one extra stage. For schematics, see figures B.3 & B.4 of Appendix B. The 'divide by 2 5' block (named 'DIVIDER') was simulated, and shown to work correctly. See section 4.3. <heading>3.4. 7 Segment Display</heading><heading>3.4.1. Driver</heading>The driver for the display will take a 4-bit natural binary input, and convert it to an 8-bit output. This would be quite a task to design in logic. Instead, the same effect can be produced with around 30 lines of VHDL code. The code used is given in Appendix C (copyright Dr. S. L. Linfoot). Using the Project Navigator, a schematic symbol was created from the VHDL code, and then the 7 segment driver could be placed in a schematic drawing like any other component. The input and output to the driver are both buses. Using bus taps, these buses were split into wires carrying separate signals. These wires must be named according to the name of the bus, for them to function correctly. <figure/>The 7 segment drivers could not be simulated; rather they were tested by connection to a BCD counter, and programmed to the FPGA. This is an example of where the programmability of an FPGA is useful (see 2.2.1). The schematic in figure B.5 (Appendix B) shows the test configuration. <heading>3.4.2. Separate Digits</heading>There are four digits to the display, each with an anode. If an anode is pulled LOW, the 7 segment driver illuminates segments on the corresponding digit. In order to show a number with multiple digits, the digits must be refreshed alternately, every 1ms and 16ms [1]. This must be done using the 50MHz clock on the D2-FT board, which will need to be scaled down by a factor between the following:  FORMULA   FORMULA  Using multiple asynchronous stages of 'divide by 2', with each stage using one flip-flop, the number of flip-flops required is between:  FORMULA   FORMULA  Rather than creating another block to scale down the 50MHz clock, an extra output was tapped from the 'div26' block, which is responsible for providing the 0.8Hz clock (section 3.3). However, the way this block was constructed means that a clock can only be tapped off after either 15 or 20 'divide by 2' stages, but no number in between. Opting for output after 20 stages, a new pin named 'div20' was added to the 'div26' schematic. Figure B.4, Appendix B. This project requires only the 2 right-most digits of the display (digits 3 & 4), therefore digits 1 & 2 were disabled by connecting their anodes to Vcc. <figure/><heading>3.5. Timing Generator</heading>The timing generator is responsible for producing two timing waveforms. The first of these supplies the clock input to the latch, the second goes to the clear input of the BCD counter. The two timing signals should look as follows: <figure/> FORMULA  <figure/>The latter signal has a 0 to 1 transition one clock cycle after the former. This means that the latch will store the value from the counter, and then the counter is reset. Coincidentally, the timing waveform in figure 1 is identical to the MSB of the BCD counter (see figure 4.2.1 for counter simulation results). Therefore, the same logic circuit was used. The timing waveform in figure 2 was produced as the AND of the MSB and LSB of a BCD counter: <table/>Output pins to the two unused bits (B and C) were removed, leaving the schematic shown in figure B.6 (Appendix B) <heading>3.6. Prescaler</heading>The task of the prescaler is to divide the input frequency by 10. This is necessary because the BCD counter counts pulses for 10 seconds. When the two components are combined, the output of the counter is the average frequency over the 10 second period. The prescaler, like the timing generator, is very similar to the BCD counter. The MSB has one 0 to 1 transition for every ten of the original clock, thus it is an effective 'divide by 10' circuit. However, the first 0 to 1 transition occurs after only 8 clock cycles, rather than 10. This can be corrected by inverting the output, giving the schematic shown in figure B.7, Appendix B. When simulated, the circuit gives the output as shown in section 4.6. <heading>3.7. Latch</heading>The latch has two purposes. Firstly it holds (latches) the value that is being shown on the display, while the BCD counter resets and counts the next value. Secondly, it takes two 4-bit input signals, and outputs one 4-bit signal to the 7 segment display driver. This output signal switches between the two stored 4-bit values at the same rate as the display is switching between digits. This ultimately gives the appearance that information is being passed to both digits simultaneously. To ensure synchronicity of these two switching actions, the latch uses the same clock input that is responsible for pulling display anodes high and low (see section 3.4.2). The latch was created in a very simple way, using a single D-type flip-flop for each input bit. The flip-flop lets a value through to its output every time a 0 to 1 transition is detected on its clock input. This clock input is received from the timing generator (section 3.5). The switching between stored values was carried out using a multiplexer on each of the 4 output bits. See figure B.8 (Appendix B) for the schematic diagram, and figure 4.7 for simulation results. <heading>3.8. Combining the Components</heading>Each component produced so far was placed inside a hierarchical block. The blocks were then combined in the configuration in figure 3.1.1, giving the schematic shown in figure B.9 (Appendix B). Since the anemometer should be capable of showing readings between 0 and 99, 2 BCD counter blocks were used, one for each digit. These supply the 8 input bits to the latch. The counter responsible for the 'units' digit, simply takes its input from the prescaler, as shown in figure 3.1.1. However the second counter must have its input divided by 10 first, so that it can supply the 'tens' digit. This input was produced by inverting the MSB from the 'units' counter. It has previously been shown that the MSB of a BCD counter effectively divides the input by 10, but that it must be inverted to have a 0 to 1 transition at the correct position (see figure 4.2.1 for BCD counter output waveform, and figure 4.6.1 for the waveform given by the MSB once it is inverted). The scan chain was linked up in the following order: <figure/>The scan chain contained 50 flip-flops altogether. All the inputs and outputs from the circuit must be assigned to the appropriate output pins of the FPGA. A pin-out table is included in Appendix D, showing which FPGA pins are connected to which peripherals on the 2 circuit boards. Scan out was connected to an LED, so that outputs can be seen. This meant that the output pin J3 (LEDG) must also be assigned. For any LEDs on the DIO4 board to be active, the pin J3 must be pulled high. In the schematic figure B.9, an output pin labelled 'LEDG' can be seen to be connected to Vcc for this purpose. The input buffer (IBUF) for the clock input was changed to a 'global clock input buffer' (IBUFG). This is necessary for the circuit to use the fast 50Mhz clock provided by the system board. An IBUFG was also used on the input for the pulses from the anemometer head. At this stage, the prototype was ready for testing. Any problems encountered were recorded and corrected. These problems and their solutions are documented in section 6. <heading>4. Findings</heading>In order to test the normal operation of the circuits in this project, all simulations were carried out with 'scanEnable' and 'clockSelect' at logic zero. <heading>4.2. BCD Counter</heading>The simulation in figure 4.2.1 shows that the bits a, b, c, d follow a natural binary sequence with 10 states, as desired. <picture/><heading>4.3. Clock</heading>The 'DIVIDER' block has been shown (figure 4.3.1) to produce one output pulse for every 2 5 (32) input pulses, which is the required result. The input and output are labelled 'timein' and 'timeout' respectively. <picture/><heading>4.4. 7 Segment Display Drivers</heading>Using the test configuration shown in figure B.5 (Appendix B), all 4 digits of the display were illuminated, at equal brightness, showing the same integer on each. This is the expected result, since all digits were receiving the same signal from the BCD counter. The digits counted through the correct sequence, 0 to 9. The display did not appear to be affected by having a refresh time slightly outside the 1ms-16ms recommendation. <heading>4.5. Timing Generator</heading>In figure 4.5.1, the waveform labelled 'timing' is exactly the waveform required. It can be seen to match the requirement shown in figure 3.5.1. <picture/><heading>4.6. Prescaler</heading>The prescaler simulation results are shown in figure 4.6.1. The waveform labelled 'div10' gives one pulse for every 10 of the input labelled 'clock'. Although the signal 'div10' is not a square wave (does not have a duty of 50%), it meets the requirement. <picture/><heading>4.7. Latch</heading>The latch simulation results are shown in figure 4.7.1. Initially, the 'timing' and 'refresh' inputs were set at 0. This caused the outputs to be zero. At 400μs, 'timing' switches to 1, causing the latch to pass through and hold the values on inputs 'ain', 'bin', 'cin', 'din'. These values are held until 'refresh' also goes to 1 after 700μs, at which time the outputs change to the values of 'tensa', 'tensb', 'tensc', 'tensd'. <picture/><heading>4.8. Combining the Components</heading>The circuit was ultimately proven to work, and be fault free. When a signal generator was used to supply the input pulses, the 7 segment display did show values slightly higher than signal generator was providing. This is to be expected, as a result of using a 0.745Hz clock instead of exactly 0.8Hz. <heading>5. Generating Test Patterns</heading>As stated in 2.2.2, to make use of the scan facilities included in the design, test patterns must be produced that will highlight any potential faults. Although these test patterns are not required at this stage (since a faulty implementation could just be reprogrammed to the FPGA), if this circuit was to be mass produced, faults could occur and each chip would need to be tested. <heading>5.1. Flip-flops</heading>All the flip-flops in the entire circuit can be tested simply, by passing through the following sequences into 'scanIn' with the circuit configured as a shift register: <list>Fifty 0s (to reset the flip-flops, and because there are 50 in the scan chain), followed by a single 1, and then fifty more zeros.Fifty 1s, a single 0, fifty 1s.0110, repeated for 50 clock cycles.</list>Each pattern should reappear at 'scanOut' unaltered. The first pattern tests for stuck at zero faults, the second for stuck at one faults, and the third tests flip-flop transitions. <heading>5.2. div26</heading>The 'div26' block can be tested fairly easily. With ScanEnable LOW and ClockSelect HIGH, the block becomes: <figure/>In this configuration, the output of each inverter is fed back to the flip-flop from which the signal came. This means that a full test for the 'div26' block would be: <list>ScanEnable = 1Shift through 26 0sScanEnable = 0Clock one cycleScanEnable = 1After a further clock cycles, scanOut should show 26 1s (since the 0s have all been inverted).</list>This process needs repeating with 26 1s, expected 26 0s at the output. <heading>5.3. BCD counter / Prescaler / Timing Generator</heading>The combinational logic into all 4 flip-flops and the inverter after each flip-flop must be tested. The patterns required are: <table/>The truth tables showing the derivation of these test patterns are in Appendix E. Since the BCD counter, prescaler and timing generator all use the same logic, they all use the same test patterns. <heading>6. Conclusions</heading><heading>6.1. Overview</heading>The project was completed within the allocated time, and to the specification. This project has been a useful introduction to the idea of designing for test, and has been an effective learning experience to become proficient with the Xilinx CAD tools. However, some problems were encountered on the way. <heading>6.2. Problems</heading><heading>6.2.1. Compile order</heading>While simulating the latch, the initial results were not as expected: <picture/>The compile order was identified as the problem. Before simulation takes place, the VHDL files must be compiled. Any code which corresponds to hierarchical blocks inside another schematic must be compiled first. The latch was created into a hierarchy block, and placed inside another schematic called 'overall'. Therefore 'latch.vhd' must be compiled before 'overall.vhd'. Figure 6.2 highlights where the compile order was incorrect. <picture/>The correct simulation results are shown in figure 4.7. <heading>6.2.2. Net names</heading>Using an option in Xilinx ECS to "select line segment" caused problems at times. If only a segment of a wire was deleted, instead of an entire branch, the remaining segments (regardless of their size, position, or connections) would retain their net name. Attempting to re-use the net name resulted in an error: <picture/>However, finding the location of the existing net (in order to remove it) was not always simple, especially during latter stages of the design. <heading>6.2.3. Refresh rate</heading>At first, the alternate refreshing or the 7 segment display digits was carried out by the 50Mhz clock without a scaler. This caused the display to not respond correctly, permanently showing symbols resembling an 8. <heading>6.2.4. Failed synthesis</heading>Occasionally synthesis of a design would fail, when the 'Tools... Check Schematic' option had failed to find bad connections. These issues had to be corrected by reading the synthesis report to locate the unconnected pins. <heading>6.2.5. Scan chain</heading>To begin with, once the circuit was functioning well as an anemometer, the scan path did not appear to work. There were altogether 50 flip flops, and so a single logic 1 should be passed through the scan chain to 'ScanOut' in 50 clock cycles. This was not the case. Intermediate scanOut LEDs were added after every hierarchical block to identify the area of the problem, which was found to be the BCD counter block. It was suspected that the timing signal going to the 'clear' input of the BCD counter was still in effect while the circuit was supposed to be configured as a scan chain. To disable this timing signal, a multiplexer was used on the 'clear' input of BCD counter. If scanSelect is 0, the clear input of the flip-flops should receive the signal from the timing generator, if 1, it should receive a logic 0 (GND). Intermediate scanOut LEDs were removed from the final schematic to cut down on output pin overhead. <heading>6.3. Improvements</heading>Cutting down on mistakes made would have significantly reduced the time required. However, as a first introduction to this software and hardware environment, mistakes are only to be expected. There are many possible improvements to the functionality of the anemometer, such as: <list>The ability to show maximum wind speed (as opposed to current speed)The ability to show average wind speed over an entire day.Alerts or audible warnings if the wind reaches certain speeds.</list>However, more important to the emphasis of this work, another test element could have been added. Many logic circuits today have a 'built in self-test' option, where the system will perform a different function if a fault is detected (e.g. not power on). 