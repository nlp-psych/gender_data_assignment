<abstract><heading>Summary</heading>The aim of the project was to determine whether a shape alternative to squares could provide a better quality image at low resolution. This was investigated by simulating pixel shapes using the OpenGL graphics software. In a direct comparison between square pixel and hexagon pixel images, square pixel images were preferred 60% of the time compared with hexagon pixel images being preferred 28% of the time. However hexagon pixel images were using between 14.29% - 14.78% less samples than the square pixel images and were therefore at a disadvantage. </abstract><list></list><heading>1. Introduction</heading><heading>1.1 Motivation</heading>Images have been displayed in many different formats over the centuries. They have decorated the walls of the caveman, been presented on paper and exhibited in galleries on canvases. However in recent times images have been shown on computer monitors and television screens. The properties of these pictures are different from all the other pictures on different formats. Images are normally continuous, however on a computer the image is made from discrete pixels. Presently the current standard for presenting digital images on computers is to use square pixels on a square sampling grid. While in most cases this is adequate it has been shown that a hexagonal sampling grid can improve on the sampling efficiency and data storage size provided by square sampling grids [1]. Changing other properties of pixels may also be able to improve certain qualities of images. Square pixels on a square sampling grid produce good quality images at high resolutions. When using the World Wide Web, webpages can take some time to load, especially when displaying many images on the webpage. To improve the speed of loading the webpage one can either obtain a faster internet connection or decrease the storage size of the images. Storage size of an image can be reduced by lowering the resolution. However at lower resolutions using square pixels on a square sampling grid can produce unwanted artefacts in an image. This is particularly the case when viewing diagonal lines at low resolution. Diagonal lines may not fall correctly on the square grid giving more of a stepping effect than a natural transition of position. Images on computers may be transferred to paper by printing them. Printing low resolution images can produce an image with grey blocky areas. Printer errors can also result in lines and streaks forming on the printout. Printers transfer ink onto the paper using circular droplets of ink. It has been suggested that using a square pixel for the original pixel and then printing using circles could be causing these grey areas. This report will investigate pixel shape and its effect on images. <heading>1.2 Background</heading>Each pixel has certain properties associated with it; the properties concerned with in this report are shape, colour and position. When producing pictures correct tessellation of pixels must be ensured otherwise there would be gaps in the image. This may be achieved by completely tiling an area with any shapes, as in a Voronoi diagram. However efficient image processing is obtained by maintaining a constant pixel shape throughout one particular image. The colour and position of pixels in an image are varied in a particular manner such that a useful image is formed. A useful image can be defined as an image from which some information can be taken. If an image is too blurred due to noise, or too low a resolution then it is not possible to make out the picture, hence there is no information in the picture and so the image is useless. As resolution is gradually reduced information is lost from the image. This may be achieved by subsampling an image. A fixed number of samples are taken from the pixel data - the fewer samples taken the lower the resolution. It is at these low resolutions where pixel shape can make a difference. At high resolutions the human eye can not discern individual pixels. So whether the image was displayed using square, diamond, trapezium or indeed any shape pixel would not make much difference. The image would still look the same; the same amount of information could be obtained. However because the resolution is so high there is much more pixel data to be stored and hence the storage size of the image increases. Image compression can be applied but this has led to artefacts appearing in images and a lowering of the quality of the image. At low resolutions using a different pixel shape could result in more information being gained from an image. <figure/>Figure 1A represents a diagonal line at high resolution. We have a very smooth line. Figure 1B represents a diagonal line at very low resolution. Here we can see the individual pixels. Figure 1C represents a diagonal line at low resolution. Here were are just about able to see the individual pixels In figure 1A we see a diagonal line at a high resolution. Here we cannot make out the individual pixels of the line. Therefore the line looks like a smooth diagonal line. However in figure 1B the resolution is a lot lower. This image is not pleasing to the human eye because we can see the individual pixels. The diagonal line can be seen as a series of squares in a stepping fashion. If the intention was to produce a diagonal line this image would be unsatisfactory. In figure 1C it is only just possible to see the pixels. The image is bordering between acceptable and unacceptable. Using a different shaped pixel in this situation could result in a smoother diagonal line, meaning a more useful image would be obtained at the same low resolution. This also applies to edges of objects. The boundary between two objects can be simply viewed as a line. An object may have edges at a variety of angles. Using the example of World Wide Web based images it would be useful to produce an image that had a low resolution, allowing it to load more quickly, but still contain useful information. Printers use circular droplets of ink or circular light spots to print images, or indeed anything else. At low resolutions printers sometimes print incorrectly leaving large areas with unwanted ink. This may be due to the mapping difference between the circular droplets and the square pixels of the original image. If the image was made of circular pixels then perhaps these printing errors would not occur. The primary objective of the project was to investigate pixel shape, alternative to square pixels, in order to provide a better quality image. The secondary objective was to investigate pixel shape in order to provide a better printout. <heading>2. Theory</heading>For the best possible approach to the project it was important to gain an understanding of the issues involved with displaying images and also the different features of different shapes. <heading>2.1 Human Eye</heading>Before deciding what pixel shape to investigate it is interesting to observe how humans perceive images. Light travels through the cornea and lens which focus the light on to the retina, located at the back of the eye. The retina is formed from two types of cell - rods and cones. The rods specialise in receiving light under poor lighting conditions and are generally very sensitive to changes in light intensity while the cones specialise in receiving colour [2]. The cones are divided into groups, those which specialise in receiving yellowish-green light, those which specialise in receiving green light and those which specialise in receiving blue light [3]. The rods and cones pick up the light signals which are sent to the visual cortex of the brain. The brain receives the main elements of the images and then fills in the spaces. The interesting point to note from the examination of the human vision system is the organisation of the rods and cones. These sensory elements are roughly hexagonal and are arranged in the hexagonal mosaic fashion as this is the most efficient packing method. Since humans are perceiving images through hexagonal receptors it may be better to view images with hexagonal pixels instead of square pixels. To ensure correct tessellation hexagonal pixels must be sampled on a hexagonal sampling grid - the benefits of the hexagonal sampling grid have already been mentioned in the introduction. Middleton and Sivaswamy suggest that hexagonal sampling exploit the oblique effect in human vision thereby providing a better image when viewed by humans [4]. <picture/><heading>2.2 Computer Images</heading>An image can be described as a continuous two-dimensional brightness field. An image must be sampled and those samples digitized before a computer can process the image. The continuous image is then reconstructed from the samples. The brightness fields can be converted to the Fourier plane where the spatial-frequencies can be analysed - the frequency with which the brightness varies across a space. For correct image reconstruction, from the samples, the spatial frequencies must be non-overlapping. However a real world image will have spatial frequency components throughout the image. If this image were to be sampled and then reconstructed, the resultant image would contain aliasing errors and would therefore be an inaccurate representation of the original image. To avoid this problem the original image must be bandlimited. Typically images have been limited to a circular shape because the circular shape limits equally in all directions [5]. Gauss proved that the hexagonal packing structure was the most efficient method when using regular circles. The hexagonal arrangement provided a density of 0.9069. Therefore more samples in a fixed space can be taken using a hexagonal sampling scheme. The increase in number of samples could provide a better quality image [6]. However if image reconstruction were to be carried out using circularly bandlimited samples there would be gaps in the resultant image. On a physical display it would not be possible to overlap the samples to form a complete tiling. However the circularly bandlimited samples can be resized to fit inside other shapes which tessellate perfectly thus allowing correct reconstruction of the original image. <figure/>As mentioned in the introduction the current standard is to use squares pixels. However it can be seen that the hexagon provides a closer match for the circle than the square. The hexagonal shape therefore saves on bandwidth which is important when dealing with internet images. <heading>2.3 Hexagons</heading>The regular hexagon polygon is formed from the connection of six equal sides where each of the interior angles is 120â—‹. The figure shows the relationship between the height and the width of a hexagon. The correct width for a regular hexagon can be obtained by simply multiplying the height by  FORMULA . <figure/>An image is formed from a two dimensional arrangement of pixels completely tiling a fixed area. It is therefore essential to ensure correct tessellation of hexagons to make sure there are no gaps in between the pixels. Due to the nature of the hexagon shape it would be necessary to offset the pixels by half a pixel on every other line for complete tiling. <figure/>There are similarities and differences when subsampling an image on to square and hexagonal grids. <figure/>When sampling in the vertical direction there is no difference between the hexagon and square sampling grids. Although the height of the hexagon and square are not the same, the interlocking action of the hexagonal sampling grid compensates for the extra height. As can be seen from figure 6 the hexagons will always appear slightly taller. However this height difference is constant no matter how many pixels are displayed; there will not be much difference over an image that may be hundreds of pixels high. The figure also shows that the square and hexagonal pixels line up in the vertical direction. The red lines are always the same distance apart. The origins of both the square and the hexagon are the same distance apart vertically; therefore the vertical subsampling will be identical for both squares on a square sampling grid and hexagons on a hexagonal sampling grid. However this is not the case for the horizontal subsampling. <figure/>The hexagon shape is wider than the equivalent square. However, unlike the vertical hexagonal sampling grid, there is no interlocking of pixels in the horizontal direction. Therefore the width of a group of hexagonal pixels will be greater than that of the square pixel. The figure shows that, even though the hexagonal pixel starts level with the square pixel, the result is that the difference between the boundaries keeps increasing. In a large image the hexagonal pixel image will result in an image that is much wider than the square pixel image. However it has already been shown that the vertical distance will be approximately the same. Therefore the hexagonal pixel image will appear distorted. For this reason the horizontal subsampling of an image must be different for square pixels on a square sampling grid and hexagons on a hexagonal sampling grid. A hexagonal sampling grid must take fewer samples in the horizontal direction to ensure that the image does not appear distorted. As mentioned earlier the correct pixels must be taken in order to ensure all the features of the original image are displayed in the reconstructed image. As mentioned earlier, research has already been carried out into the appropriate hexagonal sampling grid. It was found that every sample must be taken on a hexagonal sampling grid to match up with the square sampling grid [7]. However this number is not an integer and samples can only be taken at integer values. Therefore the closest approximation to this value is to take every seventh pixel on a hexagonal sampling grid for every sixth pixel taken on a square sampling grid. This may be further examined: for every seven pixels displayed using square pixels on a square sampling grid only six pixels should be displayed using hexagonal pixels on a hexagonal grid. In this manner it is possible to display images using hexagonal pixels on hexagonal sampling grid that is not distorted. <figure/>The same theory applies to hexagons rotated by 90 o. During testing it would be important to test both types of hexagons. <figure/><heading>2.4 Image display with Circles</heading>When placing circles on a sampling grid some adjustments have to be made compared with placing squares or hexagons. Regular circles do not tessellate with each other - therefore they do not result in a complete tiling. This leaves gaps in between the circles - an image with black spaces all over it would be unsuitable for viewing. This would occur on either a square sampling grid or on a hexagonal sampling grid. <figure/>It was therefore necessary to overlap the circles to ensure a complete tiling. <figure/>For complete tiling, through overlapping, it is necessary for the outer edge of one circle to pass through the origins of the four adjacent circles (horizontal and vertical). If there are circles overlapping each other, by half a circle in both the horizontal and vertical directions, the image dimensions would be halved. Hence circles may require a diameter that is twice the width of a hexagon or square. This method of overlapping allowed circles to be placed on either a square or hexagonal sampling grid. <heading>2.5 Ink</heading>Regardless of the method of printing the result is the same. Dots of ink are printed onto a page. The composition of inks are allows them to flow easily through even a ball point pen  [8]. Hence, when ink is placed on paper it is in its nature to flow. Therefore even though the circular ink dot is a certain size when placed, it may flow and therefore grow in size. With the inks spreading over the page they may come in to contact with each other. Therefore it is possible that the inks mix with each other to form slightly different colours in the contact regions. It is therefore important to simulate this effect when changing pixel shape to circles. <heading>2.6 Colour model</heading>As mentioned before the human eye has yellowish-green, green and blue light sensitive cones. The colour green is detected by the green light sensitive cones and the colour blue is detected by the blue light sensitive cones. However the colour red is perceived when the yellowish-green light sensitive cone is stimulated more considerably than the green light sensitive cone. This reality has produced the RGB (Red, Green and Blue) colour model due to the fact that the three colours can separately stimulate the three different cones of the human eye. Digital displays, such as televisions and computer monitors, compliment this property of human vision by using an RGB system for displaying colour. Currently monitors can display colour using 24 bits - 8 bits for the red element, 8 bits for the green element and 8 bits for the blue element of a colour. These individual elements can be set at different intensities - a different mix of intensities produces a new colour. For example, setting red to full intensity, while keeping blue and green at zero, would produce red. However, setting red to half of maximum intensity, whilst setting green and blue at a quarter of maximum intensity, would produce pink. Each of the elements can be set between 0 and 255 to produce a different intensity - using this system up to 16.7 million discrete colours can be produced [9]. The RGB model can also be described using a colour cube. The vertices of the cube represent a particular colour group. Any given point within the cube would result in colour that was a combination of the colour groups, represented by the relative distance from each of the colour groups [10]. <figure/><heading>2.7 Viewing distance</heading>The viewing distance may some effect on the resolution of an image. Less detail can be captured from an image that is far away from the eyes in comparison to an image that is nearby. Hence when viewing images from further away than normal boundaries of objects and pixels become less discernable. This can be considered equivalent to increasing the resolution of an image. However the image size would also be considered lowered. The recommended viewing distance between eyes and monitor is 25". The viewing angle should also be between 15 o and 50  o [11]. To maintain a constant resolution when enlarging pixels then viewing distance must also be increased. With these concepts in mind it was decided to investigate hexagonal and circular pixels on various sampling grids. <heading>3. Design</heading>The design section discussed the equipment chosen for investigating pixel shape followed by some of the design ideas for the software and experiments. <heading>3.1 Equipment</heading><heading>3.1.1 Graphics software</heading>Currently there is no readily available hardware for displaying hexagonal or circular pixels. Therefore the best method to study pixel shapes is to simulate using computer graphics software. The pixels on a monitor are square therefore the simulation will not provide a completely accurate representation of a hexagon or circular shape. However the definition of the shapes increases with the number of pixels used. <figure/>By drawing the hexagons large in comparison to the square screen pixels a more accurate shape can be displayed. Many software packages are available - some are easy to use, others provide the ability to control every aspect of an image or animation. A graphics package will fall into one of two broad categories. The first type is the graphics software which is easy to use, provides one-click feature changes and does most of the work for the user. However there is no high level control of what is being displayed. The second type of graphics package is fully customisable and allows full control of the screen display. However this type of package involves high level coding and takes a lot of effort to produce simple graphics in comparison to the first type of package [12]. The main aim of the project is to control pixel shape. It is unlikely that an easy-to-use graphics package would provide such a high level of control. For this reason it has been decided to investigate pixel shape using a graphics programming language. <heading>3.1.2 Graphics Programming Language</heading>Two very powerful graphics languages are DirectX and OpenGL. Both are industry standards for developing games and animations and are also frequently used by amateur programmers [13] [14]. DirectX has the limitation that it has been designed for use with Windows platform PC's, whereas OpenGL can run on any platform. The limitation of OpenGL is that it needs to be used in conjunction with another language. It was decided that the project will be carried forward using OpenGL. This is for the two following reasons: The need to work in different labs, some running Windows PC's, some running Linux machines, will require a language which is operating system independent. DirectX has a reputation of being quite difficult to learn. In the interests of project investigation and management it will be better to spend more time experimenting with ideas than coding software unnecessarily. <heading>3.1.3 Host Language</heading>OpenGL is a set of graphics libraries, which can be used in conjunction with programming languages. OpenGL is an industry standard when dealing with 2D and 3D graphics. It has been available for twelve years making it reliable, stable and well documented. Using OpenGL it is possible to draw shapes with a specified location and colour. However OpenGL needs to be used in conjunction with another high level programming language. OpenGL has been designed to be used with the C programming language and is used this way by both industry and amateur programmers. In spite of this the popularity of the Java programming language has caused the development of some Java specific OpenGL libraries. However these libraries have not been present for as long as the OpenGL language itself. This may make them less reliable and less well documented. But the advantage of using Java over C is that Java is a very powerful language and there are readily available libraries for image processing. C does not have these features so easily accessible. However this does not mean the project cannot continue when using C. Images can also be processed in packages like MATLAB. The data from the image processing can be saved in a file and then passed to the C language when appropriate. The decision to be made is whether to use Java and possibly encounter coding errors further on in the project or to use C in conjunction with MATLAB which will mean a less efficient process due to different programs. It was decided to use OpenGL in with Java as the overall process will be more efficient and easier to control if all processes are kept with in the same program. <heading>3.1.4 OpenGL Library</heading>The next decision to be made was which OpenGL library to use. To discover the best library to use it was decided to explore the official OpenGL website. The website yielded two libraries. One was JOGL (Java OpenGL) and the other was GL4Java. JOGL had the advantage that it was more widely used amongst amateur programmers and therefore more help could be found if needed. But GL4Java claimed that it had successfully converted all the features of OpenGL [17]. For this reason it was decided to use the GL4Java library because it was unknown which features of OpenGL would be required to further the project. <heading>3.2 Design of experiments</heading>Before designing the software it was better to design the experiment - thus a more suitable design for the software could be generated. One of the aims of the project was to determine whether more information could be obtained from an image, at a fixed resolution, if the pixel shape was changed. Therefore to determine whether an image had more information than another would require a direct comparison of images - however the quality of an image is subjective to the individual viewing the image. What may be high quality to one person may be less quality to another. As a result it would be important to ensure that there is less chance of bias towards one shape due to a reason other than image quality. As a result the experiment took on a psychological aspect. The images must be displayed using the same techniques where possible and the change between the different types of image must be quick. It would be unreasonable for experiment participants to continually wait for new images to load. Participants could view the images and decide whether they prefer square pixel images or hexagonal pixel images. They should also have the option of choosing no preference if they felt that there were no worthy differences between images. <heading>3.3 Design of software</heading><figure/>The image would first be loaded into the program, where it would be processed, sampled and temporarily saved. The shape desired for image display would then be chosen by the user while the corresponding sampling grid for the shape would then be determined by the program. The correct subsampling technique could then be applied to the sample set and the subsampled image data can be sent to the framebuffer. The graphics card would then display the image on the monitor. The software had been designed to ease the experiment procedure. The image shape was determined while the program is running; therefore it would be possible to alter pixel shape without calling up another instance of the program. The process was also fairly automatic. The user only needed to choose the picture and the sample shape - the program could take care of the rest. This could speed up the experiment greatly because the program did not need to wait constantly for user input. This design included the basic processes of the program and the interaction between them - however it was only a design. There may be many problems when using OpenGL and the software may need to be redesigned to overcome these problems. Also the user could only alter two inputs, pixel shape and test image. However, at a later point it may be desired to have a higher level of control while the program was running, for example the ability to zoom in to certain parts of the image for closer inspection. Hence while the design displayed was the desirable method for displaying images it may have needed to be changed once implementation begun. Pixel shape was to be investigated using the graphics programming language OpenGL in conjunction with the language Java. The experiment would involve direct image comparison from participants. <heading>4. Implementation</heading>The implementation of the design formed a major part of the project. Techniques for displaying images were tested and integrated into the main code. The methods used for forming and displaying the polygons are discussed. <heading>4.1 OpenGL Window</heading>After successfully installing the OpenGL library the language itself was further investigated. After reading several websites it was noted that a lot of effort would be required to simply generate an empty window. Due to this problem, ready written code of an empty window was taken to move forward into the pixel manipulation rather than linger in the coding problems. The code used was a GL4Java port of an OpenGL window written for C. After further investigation it was noted that this same code had been used in many amateur websites and many people had used it as a base to further their own projects. OpenGL used a double buffering system. One buffer was used for drawing graphics on to the screen while the other buffer stored the following frame for displaying. This was useful because the next frame would be instantly displayed instead of slowly wiping over the previous frame, allowing faster comparison of images whilst the program was running. <heading>4.2 Polygon Formation</heading><heading>4.2.1 Hexagon</heading>In OpenGL polygons were drawn using the 3D Cartesian coordinate system. The vertices of a polygon could be addressed as a set of coordinates and OpenGL would fill in the space in between the points. Hence the code for the hexagon polygon was written as: <quote>gl.glBegin(GL_POLYGON); gl.glVertex3d(1.732, -1.0, 0.0); gl.glVertex3d(1.732, 1.0, 0.0); gl.glVertex3d(0.0, 2.0, 0.0); gl.glVertex3d(-1.732, 1.0, 0.0); gl.glVertex3d(-1.732, -1.0, 0.0); gl.glVertex3d(0.0, -2.0, 0.0); gl.glEnd();</quote><picture/>The Z element controlled the location of the points in the Z plane. By keeping the Z element the same for each vertex would mean the shape would be kept parallel to the plane of the screen. The benefit of this was that it would be easy to simulate zooming in and out of an image by simply adjusting the z value. <picture/><quote>gl.glBegin(GL_POLYGON); gl.glVertex3d(1.732, -1.0, -10.0); gl.glVertex3d(1.732, 1.0, -10.0); gl.glVertex3d(0.0, 2.0, -10.0); gl.glVertex3d(-1.732, 1.0, -10.0); gl.glVertex3d(-1.732, -1.0, -10.0); gl.glVertex3d(0.0, -2.0, -10.0); gl.glEnd();</quote><quote>gl.glBegin(GL_POLYGON); gl.glVertex3d(1.732, -1.0, -100.0); gl.glVertex3d(1.732, 1.0, -100.0); gl.glVertex3d(0.0, 2.0, -100.0); gl.glVertex3d(-1.732, 1.0, -100.0); gl.glVertex3d(-1.732, -1.0, -100.0); gl.glVertex3d(0.0, -2.0, -100.0); gl.glEnd()</quote>The same OpenGL call, GL_POLYGON, could be used to produce other shapes but there were some specific calls for frequent shapes. The call GL_QUADS could be used to produce any four sided shape including squares and rectangles. The process for the displaying shape was the same; however, it ensured that only 4 sided shapes are produced. For the final experiment it was important for square pixel images to be displayed in the same manner as hexagon pixel images. Therefore the square was also drawn in OpenGL however swapping the command GL_POLYGON with the command GL_QUADS. <figure/><quote>gl.glBegin(GL_QUADS); gl.glVertex3d(-1.5, -1.5, -10.0); gl.glVertex3d(1.5, -1.5, -10.0); gl.glVertex3d(1.5, 1.5, -10.0); gl.glVertex3d(-1.5, 1.5, -10.0); gl.glEnd();</quote><picture/><heading>4.2.2 Circle</heading>In OpenGL there was no preset command for drawing circles. Hence, it was necessary to create circles from other shapes. After searching the World Wide Web some code was found that allowed empty circles to be drawn [16]. However the code found was written for C and had to be converted to Java first. <quote>void disp(void) { int num_lines = 5; double angle; glBegin(GL_LINE_LOOP); for(int i =0;i<num_lines;i++){ angle = i*2*M_PI/num_lines; glVertex2f(cos(angle),sin(angle)); } glEnd(); } C</quote><quote> double PI = Math.PI; double angle = 0.0; gl.glBegin(GL_LINE_LOOP); for (int i = 0; i < circle_points; i++) { angle = 2*PI*i/circle_points; } gl.glVertex3d(1.732*Math.cos(angle),1.732*Math.sin(angle), size); gl.glEnd(); Java</quote><figure/>The points on the edge of the circle were defined using the mathematic sine and cosine functions. OpenGL then joined the points together with the line due to the command GL_LINE_LOOP. The circle produced was an empty circle - only the boundary was defined. However pixels in images are coloured and hence filled circles would be required. The circle found was just a single line. However it provided some useful techniques for producing a circle. The circle was formed by defining points around the circle. OpenGL would do the rest and join the line between the points. If there were only a few points set then a less defined shape was formed. With only four points a diamond was formed. However as the number of points increased the definition of the circle improved. At 100 points the circle was well defined and had good shape. <picture/>The command GL_LINE_LOOP was swapped for the command GL_TRIANGLE_FAN. This allowed the circles to be formed from many, very thin, triangles. <figure/>The origin of the circle was set and the triangles were formed around this point in a fan-like fashion. These triangles could be filled and hence colour could be applied to the circle. <picture/><heading>4.3 Multiple Polygon Formation</heading><heading>4.3.1 Axis Translation</heading>The code to produce one hexagon was inserted into a method, which allowed the code for the hexagon to be called upon at any time. However if the method was called twice one hexagon would be drawn over by another, due to the fact that the method uses the same coordinates for the hexagons. It is possible to send in different coordinates for the hexagon to stop overlapping; however when dealing with hundreds of hexagons it would become a slow and tedious process to continually calculate new values for the hexagons. The OpenGL language can overcome this problem by using translations. By translating the origin of the axis, new hexagons can be drawn using the same values. The new hexagon would be drawn relative to the new positioning of the axis and so would not draw over the previous hexagon. <picture/><quote>hexagon; hexagon; hexagon { gl.glBegin(GL_POLYGON); gl.glVertex3d(1.732, -1.0, -15.0); gl.glVertex3d(1.732, 1.0, -15.0); gl.glVertex3d(0.0, 2.0, -15.0); gl.glVertex3d(-1.732, 1.0, -15.0); gl.glVertex3d(-1.732, -1.0, -15.0); gl.glVertex3d(0.0, -2.0, -15.0); gl.glEnd(); gl.glTranslated(3.464, 0.0, 0.0); }</quote>The translation call was inserted into the hexagon method because in most situations another hexagon would be drawn adjacent to the previous one. It would be more efficient to perform the translation and then remove it if not necessary than to check whether a translation is necessary every time. The new method made it possible to continually call the hexagon method to display hexagons in a straight line one after the other. <quote>for (i =0, i < 10, i++) { hexagon; }</quote><picture/><heading>4.3.2 Multiple Line Polygon Display</heading>The first problem related to the initial positioning of the drawing axis. It was simple enough to move it down to the next line using a simple translation of position in the Y direction. However to the move the drawing axis back to the start of the line was a bit more difficult because the program had to know how far the axis had moved in the first place. Also the program needed to know which lines had to be offset by a half a pixel. To deal with translation in the X direction the program would need to know how many hexagons had been drawn on a line to make sure it moved back the right amount. This could be achieved by recording the number of hexagons drawn. However the number of hexagons to be drawn will be fixed before any hexagons are drawn - either a number entered by a user or the pixel width of an image. Therefore this part of the problem is easily solvable. <picture/>However when dealing with the half pixel offset there were a couple of methods that could have been used. The first method would have been to draw every other line. Then the program would translate the drawing axis back to the top and draw the lines in between but offset by half a pixel. The simple Y translation could then be employed to draw in the remaining lines. The benefit of this method is that the offset only needs to be calculated once. The difficulty is that more complicated calculations are required to make sure complete tiling is obtained. <picture/>The other option was to draw every line sequentially and continually offset every other line. The benefit of using this method is that it follows a more sequential pattern making it easier to follow the code later when more difficult problems emerged. The disadvantage with using this method is that it could be deemed inefficient to continually check whether the offset was needed. <picture/>It was decided to use the method to draw every line sequentially. This was because it would be easier to link this method with the image processing later on in the project. An algorithm was developed which ensured a correct hexagonal tiling. A check was made to detect whether the line had been offset - a return of 1 would mean the line had been offset, 0 would mean it had not been offset. If a line needed to be offset, the program would detect that the offset check was 0; the line would then be offset and the offset check set to 1. If the line was already offset then the program would return the line to the original position and then reset the offset check. This algorithm made sure that the pixels were offset by half a pixel for every other line. <quote>double nextLine = hexDrawn * 3.464 + 1.732; double secondline = nextLine; if (offset == 1) { secondline = secondline - 3.464; offset = 0; } else { secondline = nextLine; offset = 1; }</quote><heading>4.4 Image display</heading><heading>4.4.1 Colour Model</heading>The subsequent section was the control of colour. There are a variety of colour models used in computer image applications. The difference between colour models is the method in which the RGB system is manipulated. OpenGL provided two different models for colour manipulation - the simple RGB model and the Colour-Index model. The RGB model relied on the user inputting the specific values for each of the red, green and blue elements to produce a desired colour. The Colour-Index mode used an index value matched against preset colours in a lookup table. <figure/>It was decided that the RGB model would be more suitable for the project. The RGB model provided a more direct manipulation and control of colour. Although it was possible to obtain a vast number of colours using the Colour-Index model, its inflexibility made it unsuitable for the image processing later on in the project. The OpenGL RGB model used 1.0 as the maximum value for an individual RGB element and 0.0 for the minimum. For example, setting each of the RGB values to 0.0 would result in the colour black. Setting all the values to 1.0 would change the colour to white. The table below gives a few examples demonstrating the colour flexibility. <table/>It was now possible to apply colour to the hexagons by using the OpenGL call, gl.Color. The call took three inputs, namely the values of the individual red, green and blue components. To colour a polygon in OpenGL the colour was set first by using the glColor call. All polygons would then be drawn with that same colour until a new colour was set. Therefore the colour for a particular hexagon had to be set before the hexagon was drawn. <quote>gl.glColor3d(0.3, 0.7, 0.5) hexagon; hexagon gl.glColor3d(0.7, 0.9, 0.4) hexagon; gl.glColor3d(0.1, 0.3, 0.4) hexagon; gl.glColor3d(0.9, 0.4, 0.1) hexagon; hexagon</quote><picture/>A test program was written which, by using hexagons, gradually went through the colour range for a few colours. This gave great promise for the future development of the project. <picture/><heading>4.4.2 Image Processing</heading>The next section of the project involved processing the images within the program. Since this would involve a lot of work developing, integrating and testing it was decided that it would be best to research ready written code on the web. As previously mentioned Java is a popular language and there is much ready written code on the web. One source provided code that would load images with JPEG, GIF and BMP codings into the Java program. Another source provided code that stored images in a method desirable for the project. The images were processed and separated into the individual pixel elements. The location and colour value of this pixel was then stored in a zero based 3D array. The first two elements of the 3D array represented the (i,j) position of the pixel whilst the third element identified the colour of the pixel. This colour value could be further processed to extract the individual red, green and blue elements of a pixel - the elements used in the RGB model. <quote>int[][][] sampledImage = imageIO.getImagePixels(img);</quote>For example, below we have a 13 x 10 pixel image of an envelope. <picture/>By enlarging the image we can see the pixel boundaries. <picture/>The program began by identifying the pixel located in position (0,0). <picture/>The program then identified the colour value of the pixel which was then stored in the 3D array. This value could be manipulated to provide the individual RGB components of the colour value. The colour values obtained were on a zero based index 256-level scale. For the pixel located at (0,0) the RGB components were 148 for red, 143 for green and 123 for blue. These values had to be divided by 255 to obtain a value between 0.0 and 1.0, the colour range of the OpenGL RGB colour model. Therefore using the OpenGL colour range the components were 0.580 for red, 0.561 for green and 0.482 for blue. For further explanation it is suitable to concentrate on a smaller number of pixels, for example, the 3x3 block of pixels formed from the top left of the envelope. <picture/>By processing this block of pixels the image is stored in memory as: <table/>These colour values can be extracted with simple array calls. For example, [0][2][RED] would return the red component of the pixel in location (0,2), which in this case is 136. These red, green and blue elements could be mapped onto a hexagonal polygon. By obtaining the colour of each individual pixel element in an image, it would be possible to convert square based images to hexagon based images. <heading>4.4.3 Image Mapping</heading>The conversion process had a specific mapping procedure. The program would begin by identifying the first pixel of the loaded image. <quote>for (int i = 0; i < (img.getHeight(this)); i++) { for (int j = 0; j < (img.getWidth(this)); j++ ) {</quote>The colour of that pixel would then be obtained. <quote>r = sampledImage[i][j][RED]; g = sampledImage[i][j][GREEN]; b = sampledImage[i][j][BLUE]; r = r / 255; g = g / 255; b = b / 255;</quote>The colour would then be sent to the hexagon call method which was modified to set OpenGL to that colour. <quote>hexagons(r, g, b);</quote>A hexagonal pixel would be drawn which would result in a hexagon with the same colour as the first square pixel. <quote>public void hexagons(double red, double green, double blue) { gl.glColor3d (red, green, blue); gl.glBegin(GL_POLYGON); gl.glVertex3d(1.732, -1.0, size); gl.glVertex3d(1.732, 1.0, size); gl.glVertex3d(0.0, 2.0, size); gl.glVertex3d(-1.732, 1.0, size); gl.glVertex3d(-1.732, -1.0, size); gl.glVertex3d(0.0, -2.0, size); gl.glEnd(); gl.glTranslated(3.464, 0.0, 0.0);</quote><picture/>The program would then identify the next pixel of the image and determine its colour. Again this colour would be set and another hexagonal pixel would be drawn. <picture/>The algorithms developed earlier ensured the hexagons were being drawn in the correct places. <picture/><picture/>The same method could be used for producing OpenGL images with square based pixels, as well rectangles or circles. In the interest of fairness it was important to ensure that square based images were displayed using the same mapping procedure as the hexagonal pixel based images. <heading>4.4.4 Clipping</heading>When creating images with pixels on a hexagonal sampling grid it was possible to see an uneven edge. This was due to the nature of the sampling grid in that every other line had to be offset by half a pixel. This uneven edge could bias judgements during the experiment phase. <picture/>It was therefore necessary to ensure that the window edge would clip off the uneven edges of the image. This could be achieved by enlarging the image until its edges were just cut off by the edges of the window. The window had been kept a constant size at 446 x 446 pixels. This produced a square window; most images are not square and are of rectangles with varying ratios between width and height. <picture/>The window therefore had to have the same dimensions as the image that was required for viewing. The size of the window had to be set before the window was created. It was also not possible to draw any graphics until the window had been created. Hence it was necessary to alter the order in which certain processes were carried out. The image had to be loaded into the program first so that the size of the window to be drawn could be determined. The window was then drawn followed by all other necessary processes. This change of processes produced a window that had the correct dimensions for an image that was to be displayed. <picture/>However the window still did not clip off the window edges. The origin of the drawing axis was in the centre of the window. For the image to fit in the window the program had to move the drawing axis to the top left corner, before displaying the image, to ensure that the image fit in the window. Finally, the enlargement of the image had to be set so that the edges were only just cut off. After investigation it was found there was a relationship between the height of the image and the zoom factor that needed to be applied. This relationship was exploited such that the edges of an image were automatically clipped when the image was displayed. <picture/><heading>4.4.5 Subsampling</heading>The final part of the displaying procedure involved subsampling the images. For subsampling a lower number of pixels had to be processed than for a normal resolution image. For square pixels every sixth pixel was taken in the horizontal direction while for every seventh pixel was taken for hexagonal pixels in the horizontal direction. Every sixth pixel was taken in the vertical direction for both sampling systems. <quote>for (int i = 1; i < img.getHeight(this); i = i + 6) { for (int j = 1; j < img.getWidth(this); j = j + 7) Hexagonal Sampling</quote><quote>for (int i = 1; i < img.getHeight(this); i = i + 6) { for (int j = 1; j < img.getWidth(this); j = j + 6) { Square Sampling</quote>The images displayed were six times smaller than normal. These had to be enlarged so that better shape formation could take place. Also on such small images it would be difficult to determine any differences. Therefore the zoom factor was adjusted to compensate for these variations. <picture/>However the resultant image was not of a very high quality. Higher resolution images would be required for testing for testing purposes. <heading>4.4.6 Alpha Element</heading>The overlapping of circles introduced new problems. With only part of the circle showing a new shape was being introduced. <picture/>Apart from the circles on the outer edge every other circle would be displayed as in figure 44. The edge circles were also not being displayed correctly. In a real printout the ink on a page may spread and mix together. This concept provided the solution to the overlapping problem. OpenGL could add a fourth element to the RGB colour model to produce the RGBA model. The fourth element was the alpha element. The alpha element controlled the transparency of polygons, or in this case, circles. With the transparency applied to the circles, the circle behind another would have more of its colour showing through. This transparency caused the colours to mix also simulating the effects on inks on a paper. <picture/><heading>4.5 Experiments</heading><heading>4.5.1 Preliminary Experiment</heading>A preliminary experiment was carried out to gain experience in performing the testing procedure. With the knowledge received from the preliminary experiment it would be possible to improve the procedure and provide a more fair and suitable final experiment. To display an image the program had to be loaded from a command line with the image file name as an argument. This made it unfeasible to change the image being displayed while the program was running, especially with different images requiring different window sizes. Therefore to change an image being displayed the current program had to be closed and a new command had to be typed into the command line with a new argument. This could take a lot of time, especially when displaying a string of images - a test participant may be unwilling to wait for such periods in between testing. Therefore a method was needed for quickly changing the image being displayed. The workstation for performing the tests was a Windows platform pc. Therefore an MS-DOS batch file was created which lined up the commands that needed to be called. All the necessary program files were compressed to a jar file which made organisation and execution of the program easier. <quote>java -jar -classpath ./ Image4.jar sakuraba.jpg java -jar -classpath ./ Image4.jar sky.jpg java -jar -classpath ./ Image4.jar house.jpg java -jar -classpath ./ Image4.jar grass.jpg</quote>As soon as one image was no longer needed, the program was closed and the next image would automatically be displayed. This process greatly reduced the changeover time between images. A similar batch process could also be created using UNIX shell script to allow the same test to be run on a workstation running UNIX. The test procedure asked participants to compare an image with different shape pixels, at varying distances, and decide which displaying of the image they preferred. The images were displayed without any sub-sampling. To ensure that the height and width of the images were still correct the dimensions of the hexagon were altered. A regular hexagon is wider than the regular square and so displaying every sample with this type of hexagon would cause a distortion in the image. Therefore the width of the hexagon was adjusted to only 3.0 units width instead of 3.464 units. This allowed images consisting of hexagons on a hexagonal sampling grid to be displayed in the same window as images consisting of squares on a square sampling grid. The four images chosen for testing were images of natural scenes. The images displayed were a face, a portion of sky, a house and a field. The dimensions of the images were also relatively small in size so that the images would load up more quickly. The images were also displayed at twice their original size to allow the graphics card to display more accurate hexagons. <picture/>The participants were asked to view one of the images. The pixels would be swapped between hexagons on a hexagonal sampling grid and squares on a square sampling grid. The participants were not told which pixel shape was being used - they were simply informed of version 1 or version 2. The version number applied was changed between the two shapes to ensure the participant did not become attached to a version number and instead chose the image they preferred. After a participant had given their answer, whether they preferred version 1, version 2 or had no preference, the image was changed so that the comparison could take place on a different image. During the test the participants were asked to stand at varying distances to simulate higher and lower resolution. First participants were asked to stand at twice the normal distance, followed by the normal distance and finishing with three times the normal distance. Since the images were being displayed at twice their actual size, viewing the image from a normal distance would simulate lower resolution because the pixel shapes could be seen more clearly. Viewing the image from twice the normal distance would be equivalent to a normal viewing and finally, viewing the images from three times the normal distance would simulate a higher resolution as the pixel shape would be harder to make out. <heading>4.5.2 Final Experiment</heading>The final experiment ran in a similar fashion to the preliminary experiment however a few important changes were made. The images displayed had gone through the subsampling process and so were of much lower resolution. Therefore when displaying the images it was not easy to tell what was being displayed. For this reason participants were shown the original images at maximum resolution to give them some idea of what the image was supposed to display. The participants were shown all the images at the beginning of the test and then were not allowed to see the images later on during the test. Because the images were being subsampled a much higher resolution original image was required so that the subsampled image would have some quality and some features of the image could be discernable. It was fairly difficult to find BMP or TIFF images that are of high resolution due to the large file size. However some JPEG images were found which did not contain any artefacting. Hence these images were suitable for testing and contained a variety of different features - some containing straight edges; others providing curves and some images had subtle colour changes. Because the images were being displayed at six times larger than usual the participant had to stand six times the normal viewing distance away. This was the correct viewing distance for the subsampled image. There were some extra features to be tested in the final test. Images with hexagons at different rotations were also tested as there could be a difference in an image displaying with a different hexagon rotation. Circles were also tested in the final experiment to provide an alternative to the squares and the hexagons. Because circles fit on either sampling grid it was important to test the circles with both of the sampling grids. Five images were chosen for the final test, again each of them displaying a natural scene. <picture/>Using these methods images could be displayed using hexagons, squares or circles on square and hexagonal sampling grids. The preliminary experiment provided improvements for the final experiment. <heading>5. Results and Analysis</heading>The actual data from the preliminary results were not the key aspect. The experience gained from running the experiment ensured a more accurate and reliable final experiment. The final experiment compared hexagon, square and circular pixels, the results of which are discussed in the following sections. <heading>5.1 Preliminary Results</heading>The images produced may be viewed in the appendix. The images displayed using square pixels were generally better quality than the images using the hexagons. At the closer ranges square pixel images were almost always preferred to hexagon pixel images. At the greatest range there were no discernable differences between the images. At the normal viewing distance the square pixel images were preferred to the hexagon pixel images. Although the alternative pixel shape did not provide positive results the purpose of the preliminary experiment was fulfilled - running an early test to devise an improved final experiment. <heading>5.1.1 Single Window</heading>An image was loaded in a window with either square or hexagon pixel images. While the program was running it was possible to change the pixel shape, and the sampling grid it was displayed on, by the touch of a button. The other option was to display images side by side. However participants may have preferred a particular side, so this chance of bias was removed. It was possible to switch between various shapes, hexagons, squares and circles as well as various sampling grids, square and hexagon. The fact that it happened in the same window increased the speed of the test. The participant did not have to wait for extra windows to be loaded. Participants also kept asking to see the two different versions again and again. The one touch button method greatly sped up this process - instead of having to continually load up new windows. <heading>5.1.2 Preference of Shape</heading>In most cases participants could not immediately decide which image they preferred. The participant had to focus on a particular part of the image or on an edge within the image. Their decision about the image was sometimes entirely based upon a single object. For example, during a test of the 'grass.jpg' image a participant revealed that their decision was based on the clarity of the dog. While this may be a valid to do in the situation where there is only one difference between the two images, in other images differences could have been overlooked. In a few test cases the resolution of the image was set very low. For example, the 'sakuraba.jpg' was zoomed in until only the nose was visible. <picture/>The participants pointed out that the squares were better for the edges, but the hexagons were better for the detail within an image. This gave some promise for the hexagon shape at certain resolutions. <heading>5.1.3 Jpeg Image File Format</heading>The image displayed were conversion of jpegs. Jpegs are compressed image files. This compression has lead to artefacts appearing in images, due to the algorithms used. Particularly when using the 'grass.jpg' image the artefacts were exaggerated when using hexagons compared with squares. This may have distorted the results for that particular image. It was therefore important to ensure that the test images used were not compressed, such as .TIFF or .BMP. If this was not possible then it would at least be better to obtain images where there were not artefacts present or the compression percentage was low. The 'sakuraba.jpg' image may also have had a smoothing effect applied to it. The effects of this were again exaggerated in hexagons as the edges of the objects were stretched out. <heading>5.1.4 Subsampling</heading>The images were not sampled, i.e. every pixel was being displayed. Even though the images were being displayed at twice their size this meant that there were only 4 pixels available on the monitor for the formation of hexagons. The graphics card overcame this problem by simply changing the colour of the monitor's pixels where it thought it was appropriate - to simulate the hexagonal sampling grid effect. This meant that a true representation of hexagons being sampling on a hexagonal grid was not being displayed. Therefore the results obtained were not of much use. However the preliminary test did give an idea of how to run the final test. It also gave pointers on how to improve the final test - choosing better images and the importance of sampling. <heading>5.2 Final Experiment Results</heading><heading>5.2.1 General results </heading><heading>5.2.1.1 Resultant Program</heading>The original aim was to produce software that would display images using hexagonal pixels on a hexagonal sampling grid. However it was beneficial to add extra features to the program. It was possible to move the picture around and zoom in to specific parts of the picture to see exactly how the pixels were forming the image. It was also possible to change between square and hexagonal sampling grids. Another feature was the ability to change shape to hexagons, squares, circles and rectangles. The hexagons could also be drawn with a different rotation and on its appropriate sampling grid. The original image was loaded into the program where the image dimensions were obtained. An appropriate window was initiated and the image was sent for processing. The sampling grid to be used was set by the user and the appropriate subsampling technique was applied to the processed image data. The shape of the pixel to be used was then set by the user and the appropriate image displayed. Any translations, transparency alterations, zooming and pixel rotation adjustments could be applied while the program was running. The final program structure resembled the following diagram <figure/><heading>5.2.1.2 Image Qualities</heading>The program produced images using various shape pixels on various sampling grids. The formations of the shapes were better than in the preliminary experiment because of the subsampling. Less samples were being used therefore the image could be enlarged to a bigger size on the same display. The hexagons were formed from 38 square display pixels which were a lot more than the 4 square display pixels used to form hexagons in the preliminary experiment. When viewed at the correct distance there was no difference between using hexagons or rectangles on a hexagonal sampling grid. Therefore rectangles were removed from the final experiment. Images displayed using circles appeared less bright than when displayed with other pixel shapes. This was due to the transparency of the circles. All images displayed using circles were set to a transparency level of 50%. Therefore the images displayed were half as bright as images displayed with other pixels. The overlapping of the circles also introduced a new problem. The images appeared blurry and unclear. However this same blurry effect removed the distinctive pixel boundaries that appeared in images using other shapes. This gave a smoother transition of colour over the image and therefore in some aspects more closely resembled a continuous image. <heading>5.2.1.3 Printing</heading>It was not yet possible to print out images. OpenGL had not been researched deeply enough to find an effective method for printing images. Screen captures could be taken which did allow printing. However the captures did not contain enough detail to make them suitable for printing. Any captures taken would also be taken using square pixels on a square sampling grid thus defeating the purpose of printing. Therefore there was no result for the secondary objective. <heading>5.2.2 Test results</heading>The images produced may be viewed in the appendix. <heading>5.2.2.1 Pixel Comparison</heading><heading>Vertical Hexagons against Horizontal Hexagons</heading>The first test to consider was the orientation of the hexagon shape. It was important to decide which hexagon shape provided the best image. The better of the two orientations could then be used for comparison against squares and circles. The set of five images were tested on three different people. <table/>In general it was found that images displaying vertical hexagons were preferred twice as many times to the horizontal hexagons. The vertical hexagons appeared to display straight horizontal edges better than the horizontal hexagons. However the opposite was the case for vertical straight edges. However in some images there did not appear to be many straight edges at all and still the vertical hexagons were preferred. Therefore vertical hexagons were used in the remaining tests when hexagon pixels were required. <heading>Circles on Hexagonal Sampling Grid against Circles on Square Sampling Grid</heading>The next test involved testing circles on the two different sampling grids. Overlapping circles could be displayed on either square sampling grids or hexagonal sampling grids - both would give a complete tiling. However the sampling grids did affect the resultant image in different ways. Again the set of images were tested on three people. <table/>It was found that circles displayed on a hexagonal sampling grid were preferred more than twice as many times as the circles displayed on a square sampling grid. The transparency of the circles introduced a problem with the images. In an area of one circle there were portions where there was no overlapping and portions where there were four circles overlapping each other. The result was lighter and darker sections within the single circle pixel area. This effect was present in all circles and led to a grid effect on the images. However the grid could be seen more clearly in the images using a square sampling grid. For this reason some participants preferred circles to be displayed on a hexagonal sampling grid - therefore circles would be displayed on a hexagonal grid for the remainder of the tests. <heading>Hexagons against Squares</heading>The hexagon pixel images, displayed on a hexagonal sampling grid, were compared with square pixel images, displayed on a square sampling grid. The set of five images were tested on five different people. <table/>60% of participants preferred square pixel images compared to 28% of participants who preferred hexagonal pixel images. 12% of participants had no preference between the images. However it is important to note the total number of samples used in each case. The different sampling grids required a different number of samples. For the 800x600 images 13,300 samples were used for a square pixel image whereas only 11,400 samples were used for the hexagon pixel images. The 691x922 image was displayed using 17,595 samples for the square pixels whereas only 14,994 samples were used for hexagon pixels. Hexagon image pixels were displayed using between 14.29% - 14.78% less pixels than with square images. As mentioned earlier if there are fewer samples in an image then there is less information content; the square pixel images had more than a tenth extra information in the image than the hexagon pixel images. However with a lower number of samples and therefore lower information content, the hexagon pixel images were still preferred 28% percent of the time - almost a third of all cases. Additionally in over 10% of cases there was no preference - demonstrating that squares were not deemed better than the hexagons in more cases. If the hexagons were displayed using the same number of samples the gap between the results may be closed down. However the dimensions of the images would be slightly different, although the aspect ratio would remain the same. <heading>Circles against Squares</heading>Images using circle pixels on hexagonal sampling grid were compared with square pixel images. The set of five images were tested on five different people. <table/>Again the square pixel images were preferred in 60% of all cases. The circle pixels were preferred in 32% of cases and there was no preference in 8% of all cases. Once more because circles were displayed on a hexagonal sampling grid a fewer number of samples were used compared to the square pixel images. This must be taken into account when comparing the results. However it is interesting to note that the circles performed slightly better than the hexagons in the same situation. <heading>Hexagons against Circles</heading>Hexagon pixel images were compared to circle pixel images. The images were subsampled on a hexagonal sampling grid. Once again the set of five images were tested on five different people. <table/>The hexagonal pixel images were preferred in 68% of all cases. The circle pixel images were preferred in 32% of all cases. There were no instances of no preference being chosen in a test case. Therefore it was quite clear which image provided the best quality. Both images were being displayed with the same number of samples and on the same sampling grid. The smoothing effect of the circles images were outweighed by the blurry and brightness factors. <heading>5.2.2.2 Image comparison</heading>By comparing the results of each image individually trends in the results may be established. <heading>Bluehills</heading><table/>In this image there are not many straight edges - only the curves of the hill. In this situation the pixels using the hexagonal sampling grid are preferred more often than the square pixel using the square sampling grid. As stated in the introduction square pixels are more suited to straight horizontal and vertical edges. This factor may have attributed to the square pixel not performing so well in this image. A large proportion of the original image was blue. The change between the different intensities of blue was subtle. The smoothing, blurring effect of the circles helped to preserve this subtle change whereas the hexagon pixels defined the pixel boundary too clearly. <heading>Sunset</heading><table/>Although there were some straight lines in this image the hexagon pixel was preferred more than the square pixel. At such low resolutions the hexagonal pixel performed just as well as the square pixel on the horizontal straight edges. The remainder of the image consisted of curves non-regular shapes. Although there were not too many clashing colours adjacent to each other the circle proved to blur edges too much for the participants. <heading>Sky</heading><table/>Even though the resolution was low the hexagon pixel did not perform as well as square pixels on vertical straight lines. Because the tower is the main focus of the image participants based their decision on the quality of the tower. When viewing the clouds or the rest of the sky there is not much difference between the hexagon pixels and the square pixels. There was not much difference between preference of hexagon pixels and circle pixels. <heading>Water Lilies</heading><table/>The image provides many interesting features. The edges of the leaves are fairly straight and at varying angles. There any many curves in the leaves in the background and finally there are many near-vertical straight edges displayed by the stalk of the flowers. It is found that the square pixel image was most preferred. Over the range of feature present in the image the square pixel may handle them better in general whereas the hexagon may excel with some features whilst not performing so well with others. More detail in the flowers is displayed when using square pixels. The circles blur the detail in the flowers too much thus removing some of the information in the image. <heading>Autumn</heading><table/>The final image has much detail in the leaves. The leaves are fairly small and one of the pixels is sometimes larger than the leaf itself. A lot of detail is lost due to the subsampling techniques. However, square pixels were still preferred over hexagons, perhaps because the square pixels covered a lower surface area and so resembled the leaves more closely. The circles blurred the leaves of the image far too much resulting in a 0% preference percentage for this particular image. <heading>6. Conclusion</heading>The project aim was to investigate the effects of pixel shape on images at low resolution. Changing the pixel shape had many different effects - using hexagons provided more detail but was poor for edges; using circles applied a smoothing effect and blurred the image but the overall brightness of an image was decreased. Hexagon pixel images were preferred over circle pixel images however square pixel images were preferred over both hexagon and circle pixel images. This was mainly due to the straight edges provided by the square pixels. However images displayed using hexagonal sampling grids were using roughly 14% less samples than when using the square sampling grid - therefore images were being displayed with less information content. The project could still be further developed by investigating different pixel shapes when the number of samples in either square sampled or hexagonally sampled images were the same. Ultimately it would be desirable to test hexagonal images on hardware that was capable of using hexagonal pixels. This would remove the simulation effects and be a true test. The experiments could be performed by a psychologist to ensure the tests were fair. The secondary objective of the project was never achieved and hence could still be investigated further. The main project aim was achieved - the effect of pixel shape on images was investigated. However the solution to the problems discussed at the beginning of the report were not attained. The secondary objective was not accomplished due to lack of understanding of the OpenGL graphics language. 